package #pkg

import kotlin.random.Random

class #TList(
    val buffer: #TArray,
) {

    constructor(
        capacity: Int = 0,
        init: (Int) -> #T = { #DEFAULT_VALUE }
    ) : this(#TArray(capacity, init))

    private var position: Int = 0

    val size: Int get() = position

    val indices: IntRange get() = buffer.indices

    val lastIndex: Int get() = buffer.lastIndex

    fun isEmpty(): Boolean {
        return position == 0
    }

    fun first(): #T = buffer.first()

    inline fun first(crossinline predicate: (#T) -> Boolean): #T {
        return buffer.first(predicate)
    }

    fun last(): #T = buffer.last()

    inline fun last(crossinline predicate: (#T) -> Boolean): #T {
        return buffer.last(predicate)
    }

    fun clone(): #TList = #TList(buffer.size)

    fun add(value: #T) {
        buffer[position++] = value
    }

    operator fun set(index: Int, value: #T) {
        buffer[index] = value
    }

    operator fun get(index: Int): #T = buffer[index]

    fun push(element: #T) {
        add(element)
    }

    fun pop(): #T {
        if (position > 0) {
            return buffer[position--]
        } else {
            throw IndexOutOfBoundsException("list position <= 0")
        }
    }

    fun clear() {
        position = 0
    }

    inline fun forEachIndexed(crossinline block: (i: Int, v: #T) -> Unit) {
        buffer.forEachIndexed(block)
    }

    inline fun forEach(crossinline block: (v: #T) -> Unit) {
        buffer.forEach(block)
    }

    inline fun filterIndexed(crossinline block: (i: Int, v: #T) -> Boolean): #TList {
        val result = #TList(buffer.size)
        buffer.forEachIndexed { i, v ->
            if (block(i, v)) {
                result.add(v)
            }
        }
        return result
    }

    inline fun filter(crossinline block: (v: #T) -> Boolean): #TList {
        val result = #TList(buffer.size)
        buffer.forEach {
            if (block(it)) {
                result.add(it)
            }
        }
        return result
    }

    inline fun findIndexed(default: #T, crossinline block: (i: Int, v: #T) -> Boolean): #T {
        buffer.forEachIndexed { i, v ->
            if (block(i, v)) return v
        }
        return default
    }

    inline fun find(default: #T, crossinline block: (v: #T) -> Boolean): #T {
        buffer.forEach {
            if (block(it)) return it
        }
        return default
    }

    fun sort() {
        buffer.sort()
    }

    fun sortDescending() {
        buffer.sortDescending()
    }

    fun sorted(): #TList {
        val result = #TList(buffer.size)
        result.sort()
        return result
    }

    fun sortedDescending(): #TList {
        val result = #TList(buffer.size)
        result.sortedDescending()
        return result
    }

    inline fun sortWith(crossinline comparator: (v1: #T, v2: #T) -> Int) {
        fun quicksort(from: Int, to: Int) {
            if (from >= to) return
            val pivot = this[(from + to) ushr 1]
            var i = from
            var j = to
            while (i <= j) {
                while (comparator(this[i], pivot) < 0) i++
                while (comparator(this[j], pivot) > 0) j--
                if (i <= j) {
                    val tmp = this[i]
                    this[i] = this[j]
                    this[j] = tmp
                    i++
                    j--
                }
            }
            if (from < j) quicksort(from, j)
            if (i < to) quicksort(i, to)
        }
        quicksort(0, buffer.lastIndex)
    }

    inline fun sortedWith(crossinline comparator: (v1: #T, v2: #T) -> Int): #TList {
        return #TList(buffer.size).apply {
            sortWith(comparator)
        }
    }

    inline fun sortBy(crossinline selector: (v: #T) -> Int) {
        fun quicksort(from: Int, to: Int) {
            if (from >= to) return
            val pivotKey = selector(this[(from + to) ushr 1])
            var i = from
            var j = to
            while (i <= j) {
                while (selector(this[i]) < pivotKey) i++
                while (selector(this[j]) > pivotKey) j--
                if (i <= j) {
                    val tmp = this[i]
                    this[i] = this[j]
                    this[j] = tmp
                    i++
                    j--
                }
            }
            if (from < j) quicksort(from, j)
            if (i < to) quicksort(i, to)
        }
        quicksort(0, buffer.lastIndex)
    }

    inline fun sortedBy(crossinline selector: (v: #T) -> Int): #TList {
        return #TList(buffer.size).apply {
            sortBy(selector)
        }
    }

    fun slice(indices: IntRange): #TList {
        return #TList(buffer.sliceArray(indices))
    }

    fun sum(): Int {
        return buffer.sum()
    }

    inline fun sumOf(crossinline selector: (#T) -> Int): Int {
        return buffer.sumOf(selector)
    }

    fun shuffle(random: Random = Random) {
        buffer.shuffle(random)
    }

    fun shuffled(random: Random = Random): #TList {
        return #TList(buffer.size).apply {
            shuffle(random)
        }
    }

    fun fill(element: #T, fromIndex: Int = 0, toIndex: Int = size) {
        buffer.fill(element, fromIndex, toIndex)
    }

}